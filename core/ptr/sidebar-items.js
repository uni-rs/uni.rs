initSidebarItems({"fn":[["null","Creates a null raw pointer.Examples"],["null_mut","Creates a null mutable raw pointer.Examples"],["read","Reads the value from `src` without moving it. This leaves the memory in `src` unchanged.SafetyBeyond accepting a raw pointer, this is unsafe because it semantically moves the value out of `src` without preventing further usage of `src`. If `T` is not `Copy`, then care must be taken to ensure that the value at `src` is not used before the data is overwritten again (e.g. with `write`, `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use because it will attempt to drop the value previously at `*src`."],["read_and_drop",""],["read_volatile","Performs a volatile read of the value from `src` without moving it. This leaves the memory in `src` unchanged.Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations. See the LLVM documentation on [volatile].SafetyBeyond accepting a raw pointer, this is unsafe because it semantically moves the value out of `src` without preventing further usage of `src`. If `T` is not `Copy`, then care must be taken to ensure that the value at `src` is not used before the data is overwritten again (e.g. with `write`, `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use because it will attempt to drop the value previously at `*src`."],["replace","Replaces the value at `dest` with `src`, returning the old value, without dropping either.SafetyThis is only unsafe because it accepts a raw pointer. Otherwise, this operation is identical to `mem::replace`."],["swap","Swaps the values at two mutable locations of the same type, without deinitializing either. They may overlap, unlike `mem::swap` which is otherwise equivalent.SafetyThis is only unsafe because it accepts a raw pointer."],["write","Overwrites a memory location with the given value without reading or dropping the old value.SafetyThis operation is marked unsafe because it accepts a raw pointer.It does not drop the contents of `dst`. This is safe, but it could leak allocations or resources, so care must be taken not to overwrite an object that should be dropped.This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been `read` from."],["write_volatile","Performs a volatile write of a memory location with the given value without reading or dropping the old value.Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations. See the LLVM documentation on [volatile].SafetyThis operation is marked unsafe because it accepts a raw pointer.It does not drop the contents of `dst`. This is safe, but it could leak allocations or resources, so care must be taken not to overwrite an object that should be dropped.This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been `read` from."]],"struct":[["Shared","A wrapper around a raw non-null `*mut T` that indicates that the possessor of this wrapper has shared ownership of the referent. Useful for building abstractions like `Rc<T>` or `Arc<T>`, which internally use raw pointers to manage the memory that they own."],["Unique","A wrapper around a raw non-null `*mut T` that indicates that the possessor of this wrapper owns the referent. This in turn implies that the `Unique<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a raw `*mut T` (which conveys no particular ownership semantics).  It also implies that the referent of the pointer should not be modified without a unique path to the `Unique` reference. Useful for building abstractions like `Vec<T>` or `Box<T>`, which internally use raw pointers to manage the memory that they own."]]});